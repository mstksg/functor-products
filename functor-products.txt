-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-products#readme</a>
@package functor-products
@version 0.1.0.0

module Data.Type.Functor.Product
class (PFunctor f, SFunctor f, PFoldable f, SFoldable f) => FProd (f :: Type -> Type) where {
    type family Elem f = (i :: f k -> k -> Type) | i -> f;
    type family Prod f = (p :: (k -> Type) -> f k -> Type) | p -> f;
}
singProd :: FProd f => Sing as -> Prod f Sing as
withIndices :: FProd f => Prod f g as -> Prod f (Elem f as :*: g) as
traverseProd :: forall g h as m. (FProd f, Applicative m) => (forall a. g a -> m (h a)) -> Prod f g as -> m (Prod f h as)
zipWithProd :: FProd f => (forall a. g a -> h a -> j a) -> Prod f g as -> Prod f h as -> Prod f j as
htraverse :: (FProd f, Applicative m) => Sing ff -> (forall a. g a -> m (h (ff @@ a))) -> Prod f g as -> m (Prod f h (Fmap ff as))
ixProd :: FProd f => Elem f as a -> Lens' (Prod f g as) (g a)
toRec :: FProd f => Prod f g as -> Rec g (ToList as)
withPureProd :: FProd f => Prod f g as -> (PureProd f as => r) -> r
type Shape f = (Prod f Proxy :: f k -> Type)
class PureProd (f :: Type -> Type) (as :: f k)
pureProd :: PureProd f as => (forall a. g a) -> Prod f g as
pureShape :: PureProd f as => Shape f as
class PureProdC (f :: Type -> Type) c (as :: f k)
pureProdC :: PureProdC f c as => (forall a. c a => g a) -> Prod f g as
class ReifyConstraintProd (f :: Type -> Type) c (g :: k -> Type) (as :: f k)
reifyConstraintProd :: ReifyConstraintProd f c g as => Prod f g as -> Prod f (Dict c :. g) as
class FProd f => ProdSing f
prodSing :: ProdSing f => Prod f Sing as -> Sing as
type AllConstrainedProd c as = AllConstrained c (ToList as)
indexProd :: FProd f => Elem f as a -> Prod f g as -> g a

-- | Extract the item from the container witnessed by the <a>Elem</a>
indexSing :: forall f as a. FProd f => Elem f as a -> Sing as -> Sing a
singShape :: FProd f => Sing as -> Shape f as
mapProd :: FProd f => (forall a. g a -> h a) -> Prod f g as -> Prod f h as
foldMapProd :: (FProd f, Monoid m) => (forall a. g a -> m) -> Prod f g as -> m
hmap :: FProd f => Sing ff -> (forall a. g a -> h (ff @@ a)) -> Prod f g as -> Prod f h (Fmap ff as)
zipProd :: FProd f => Prod f g as -> Prod f h as -> Prod f (g :*: h) as
imapProd :: FProd f => (forall a. Elem f as a -> g a -> h a) -> Prod f g as -> Prod f h as
itraverseProd :: (FProd f, Applicative m) => (forall a. Elem f as a -> g a -> m (h a)) -> Prod f g as -> m (Prod f h as)
ifoldMapProd :: (FProd f, Monoid m) => (forall a. Elem f as a -> g a -> m) -> Prod f g as -> m

-- | <tt>foldMapUni</tt> but with access to the index.
ifoldMapSing :: forall f k (as :: f k) m. (FProd f, Monoid m) => (forall a. Elem f as a -> Sing a -> m) -> Sing as -> m

-- | A <a>foldMap</a> over all items in a collection.
foldMapSing :: forall f k (as :: f k) m. (FProd f, Monoid m) => (forall (a :: k). Sing a -> m) -> Sing as -> m

-- | An implementation of equality testing for all <a>FProd</a> instances,
--   as long as each of the items are instances of <a>Eq</a>.
eqProd :: (FProd f, ReifyConstraintProd f Eq g as) => Prod f g as -> Prod f g as -> Bool

-- | An implementation of order comparison for all <a>FProd</a> instances,
--   as long as each of the items are instances of <a>Ord</a>.
compareProd :: (FProd f, ReifyConstraintProd f Ord g as) => Prod f g as -> Prod f g as -> Ordering

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&

-- | Witness an item in a type-level list by providing its index.
data Index :: [k] -> k -> Type
[IZ] :: Index (a : as) a
[IS] :: Index bs a -> Index (b : bs) a
data PMaybe :: (k -> Type) -> Maybe k -> Type
[PNothing] :: PMaybe f  'Nothing
[PJust] :: f a -> PMaybe f ( 'Just a)

-- | Witness an item in a type-level <a>Maybe</a> by proving the
--   <a>Maybe</a> is <a>Just</a>.
data IJust :: Maybe k -> k -> Type
[IJust] :: IJust ( 'Just a) a
data PEither :: (k -> Type) -> Either j k -> Type
[PLeft] :: PEither f ( 'Left e)
[PRight] :: f a -> PEither f ( 'Right a)

-- | Witness an item in a type-level <tt><a>Either</a> j</tt> by proving
--   the <a>Either</a> is <a>Right</a>.
data IRight :: Either j k -> k -> Type
[IRight] :: IRight ( 'Right a) a
data NERec :: (k -> Type) -> NonEmpty k -> Type
[:&|] :: f a -> Rec f as -> NERec f (a :| as)
infixr 5 :&|

-- | Witness an item in a type-level <a>NonEmpty</a> by either indicating
--   that it is the "head", or by providing an index in the "tail".
data NEIndex :: NonEmpty k -> k -> Type
[NEHead] :: NEIndex (a :| as) a
[NETail] :: Index as a -> NEIndex (b :| as) a
data PTup :: (k -> Type) -> (j, k) -> Type
[PSnd] :: f a -> PTup f '(w, a)

-- | Trivially witness an item in the second field of a type-level tuple.
data ISnd :: (j, k) -> k -> Type
[ISnd] :: ISnd '(a, b) b
data PIdentity :: (k -> Type) -> Identity k -> Type
[PIdentity] :: f a -> PIdentity f ( 'Identity a)

-- | Trivially witness the item held in an <a>Identity</a>.
data IIdentity :: Identity k -> k -> Type
[IId] :: IIdentity ( 'Identity x) x

-- | Test if two indices point to the same item in a list.
--   
--   We have to return a <a>Maybe</a> here instead of a <a>Decision</a>,
--   because it might be the case that the same item might be duplicated in
--   a list. Therefore, even if two indices are different, we cannot prove
--   that the values they point to are different.
sameIndexVal :: Index as a -> Index as b -> Maybe (a :~: b)

-- | Test if two indices point to the same item in a non-empty list.
--   
--   We have to return a <a>Maybe</a> here instead of a <a>Decision</a>,
--   because it might be the case that the same item might be duplicated in
--   a list. Therefore, even if two indices are different, we cannot prove
--   that the values they point to are different.
sameNEIndexVal :: NEIndex as a -> NEIndex as b -> Maybe (a :~: b)

-- | Kind-indexed singleton for <a>Index</a>. Provided as a separate data
--   declaration to allow you to use these at the type level. However, the
--   main interface is still provided through the newtype wrapper
--   <a>SIndex'</a>, which has an actual proper <a>Sing</a> instance.
data SIndex as a :: Index as a -> Type
[SIZ] :: SIndex (a : as) a  'IZ
[SIS] :: SIndex bs a i -> SIndex (b : bs) a ( 'IS i)

-- | Kind-indexed singleton for <a>IJust</a>. Provided as a separate data
--   declaration to allow you to use these at the type level. However, the
--   main interface is still provided through the newtype wrapper
--   <a>SIJust'</a>, which has an actual proper <a>Sing</a> instance.
--   
--   This distinction will be unnecessary once <a>Sing</a> is a type
--   family.
data SIJust as a :: IJust as a -> Type
[SIJust] :: SIJust ( 'Just a) a  'IJust

-- | Kind-indexed singleton for <a>IRight</a>. Provided as a separate data
--   declaration to allow you to use these at the type level. However, the
--   main interface is still provided through the newtype wrapper
--   <a>SIRight'</a>, which has an actual proper <a>Sing</a> instance.
data SIRight as a :: IRight as a -> Type
[SIRight] :: SIRight ( 'Right a) a  'IRight

-- | Kind-indexed singleton for <a>NEIndex</a>. Provided as a separate data
--   declaration to allow you to use these at the type level. However, the
--   main interface is still provided through the newtype wrapper
--   <a>SNEIndex'</a>, which has an actual proper <a>Sing</a> instance.
data SNEIndex as a :: NEIndex as a -> Type
[SNEHead] :: SNEIndex (a :| as) a  'NEHead
[SNETail] :: SIndex as a i -> SNEIndex (b :| as) a ( 'NETail i)

-- | Kind-indexed singleton for <a>ISnd</a>. Provided as a separate data
--   declaration to allow you to use these at the type level. However, the
--   main interface is still provided through the newtype wrapper
--   <a>SISnd'</a>, which has an actual proper <a>Sing</a> instance.
data SISnd as a :: ISnd as a -> Type
[SISnd] :: SISnd '(a, b) b  'ISnd

-- | Kind-indexed singleton for <a>IIdentity</a>. Provided as a separate
--   data declaration to allow you to use these at the type level. However,
--   the main interface is still provided through the newtype wrapper
--   <a>SIIdentity'</a>, which has an actual proper <a>Sing</a> instance.
data SIIdentity as a :: IIdentity as a -> Type
[SIId] :: SIIdentity ( 'Identity a) a  'IId

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
data ElemSym0 (f :: Type -> Type) :: f k ~> k ~> Type
data ElemSym1 (f :: Type -> Type) :: f k -> k ~> Type
type ElemSym2 (f :: Type -> Type) (as :: f k) (a :: k) = Elem f as a
data ProdSym0 (f :: Type -> Type) :: (k -> Type) ~> f k ~> Type
data ProdSym1 (f :: Type -> Type) :: (k -> Type) -> f k ~> Type
type ProdSym2 (f :: Type -> Type) (g :: k -> Type) (as :: f k) = Prod f g as
instance forall k (as :: [k]) (a :: k). GHC.Show.Show (Data.Type.Functor.Product.Index as a)
instance forall k (as :: [k]) (a :: k). GHC.Classes.Eq (Data.Type.Functor.Product.Index as a)
instance forall k (as :: [k]) (a :: k). GHC.Classes.Ord (Data.Type.Functor.Product.Index as a)
instance forall k (as :: [k]) (a :: k) (i :: Data.Type.Functor.Product.Index as a). GHC.Show.Show (Data.Type.Functor.Product.SIndex as a i)
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k). GHC.Show.Show (Data.Type.Functor.Product.IJust as a)
instance forall k (a :: k). GHC.Read.Read (Data.Type.Functor.Product.IJust ('GHC.Maybe.Just a) a)
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k). GHC.Classes.Eq (Data.Type.Functor.Product.IJust as a)
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k). GHC.Classes.Ord (Data.Type.Functor.Product.IJust as a)
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k) (i :: Data.Type.Functor.Product.IJust as a). GHC.Show.Show (Data.Type.Functor.Product.SIJust as a i)
instance forall j k (as :: Data.Either.Either j k) (a :: k). GHC.Show.Show (Data.Type.Functor.Product.IRight as a)
instance forall j k (a :: k). GHC.Read.Read (Data.Type.Functor.Product.IRight ('Data.Either.Right a) a)
instance forall j k (as :: Data.Either.Either j k) (a :: k). GHC.Classes.Eq (Data.Type.Functor.Product.IRight as a)
instance forall j k (as :: Data.Either.Either j k) (a :: k). GHC.Classes.Ord (Data.Type.Functor.Product.IRight as a)
instance forall j k (as :: Data.Either.Either j k) (a :: k) (i :: Data.Type.Functor.Product.IRight as a). GHC.Show.Show (Data.Type.Functor.Product.SIRight as a i)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). GHC.Show.Show (Data.Type.Functor.Product.NEIndex as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). GHC.Classes.Eq (Data.Type.Functor.Product.NEIndex as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). GHC.Classes.Ord (Data.Type.Functor.Product.NEIndex as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k) (i :: Data.Type.Functor.Product.NEIndex as a). GHC.Show.Show (Data.Type.Functor.Product.SNEIndex as a i)
instance forall a1 (f :: a1 -> *) (a2 :: a1) (as :: [a1]). (GHC.Show.Show (f a2), Data.Vinyl.Core.RMap as, Data.Vinyl.Core.ReifyConstraint GHC.Show.Show f as, Data.Vinyl.Core.RecordToList as) => GHC.Show.Show (Data.Type.Functor.Product.NERec f (a2 'GHC.Base.:| as))
instance forall a1 (f :: a1 -> *) (a2 :: a1) (as :: [a1]). (GHC.Classes.Eq (f a2), GHC.Classes.Eq (Data.Vinyl.Core.Rec f as)) => GHC.Classes.Eq (Data.Type.Functor.Product.NERec f (a2 'GHC.Base.:| as))
instance forall a1 (f :: a1 -> *) (a2 :: a1) (as :: [a1]). (GHC.Classes.Ord (f a2), GHC.Classes.Ord (Data.Vinyl.Core.Rec f as)) => GHC.Classes.Ord (Data.Type.Functor.Product.NERec f (a2 'GHC.Base.:| as))
instance forall j k (as :: (j, k)) (a :: k). GHC.Show.Show (Data.Type.Functor.Product.ISnd as a)
instance forall k j (a :: j) (b :: k). GHC.Read.Read (Data.Type.Functor.Product.ISnd '(a, b) b)
instance forall j k (as :: (j, k)) (a :: k). GHC.Classes.Eq (Data.Type.Functor.Product.ISnd as a)
instance forall j k (as :: (j, k)) (a :: k). GHC.Classes.Ord (Data.Type.Functor.Product.ISnd as a)
instance forall j k (as :: (j, k)) (a :: k) (i :: Data.Type.Functor.Product.ISnd as a). GHC.Show.Show (Data.Type.Functor.Product.SISnd as a i)
instance forall j k (f :: k -> *) (a :: k) (w :: j). GHC.Show.Show (f a) => GHC.Show.Show (Data.Type.Functor.Product.PTup f '(w, a))
instance forall j k (f :: k -> *) (a :: k) (w :: j). GHC.Read.Read (f a) => GHC.Read.Read (Data.Type.Functor.Product.PTup f '(w, a))
instance forall j k (f :: k -> *) (a :: k) (w :: j). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Type.Functor.Product.PTup f '(w, a))
instance forall j k (f :: k -> *) (a :: k) (w :: j). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Type.Functor.Product.PTup f '(w, a))
instance forall k (as :: Data.Functor.Identity.Identity k) (a :: k). GHC.Show.Show (Data.Type.Functor.Product.IIdentity as a)
instance forall k (a :: k). GHC.Read.Read (Data.Type.Functor.Product.IIdentity ('Data.Functor.Identity.Identity a) a)
instance forall k (as :: Data.Functor.Identity.Identity k) (a :: k). GHC.Classes.Eq (Data.Type.Functor.Product.IIdentity as a)
instance forall k (as :: Data.Functor.Identity.Identity k) (a :: k). GHC.Classes.Ord (Data.Type.Functor.Product.IIdentity as a)
instance forall k (as :: Data.Functor.Identity.Identity k) (a :: k) (i :: Data.Type.Functor.Product.IIdentity as a). GHC.Show.Show (Data.Type.Functor.Product.SIIdentity as a i)
instance forall a1 (f :: a1 -> *) (a2 :: a1). GHC.Show.Show (f a2) => GHC.Show.Show (Data.Type.Functor.Product.PIdentity f ('Data.Functor.Identity.Identity a2))
instance forall a1 (f :: a1 -> *) (a2 :: a1). GHC.Read.Read (f a2) => GHC.Read.Read (Data.Type.Functor.Product.PIdentity f ('Data.Functor.Identity.Identity a2))
instance forall a1 (f :: a1 -> *) (a2 :: a1). GHC.Classes.Eq (f a2) => GHC.Classes.Eq (Data.Type.Functor.Product.PIdentity f ('Data.Functor.Identity.Identity a2))
instance forall a1 (f :: a1 -> *) (a2 :: a1). GHC.Classes.Ord (f a2) => GHC.Classes.Ord (Data.Type.Functor.Product.PIdentity f ('Data.Functor.Identity.Identity a2))
instance Data.Type.Functor.Product.FProd Data.Functor.Identity.Identity
instance Data.Type.Functor.Product.ProdSing Data.Functor.Identity.Identity
instance forall k (a :: k). Data.Type.Functor.Product.PureProd Data.Functor.Identity.Identity ('Data.Functor.Identity.Identity a)
instance forall a1 (c :: a1 -> GHC.Types.Constraint) (a2 :: a1). c a2 => Data.Type.Functor.Product.PureProdC Data.Functor.Identity.Identity c ('Data.Functor.Identity.Identity a2)
instance forall a1 (c :: * -> GHC.Types.Constraint) (g :: a1 -> *) (a2 :: a1). c (g a2) => Data.Type.Functor.Product.ReifyConstraintProd Data.Functor.Identity.Identity c g ('Data.Functor.Identity.Identity a2)
instance forall k (x :: k). Data.Singletons.Internal.SingI 'Data.Type.Functor.Product.IId
instance forall k (as :: Data.Functor.Identity.Identity k) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Functor.Product.IIdentity as a)
instance forall k (as :: Data.Functor.Identity.Identity k) (a :: k). Data.Singletons.Decide.SDecide (Data.Type.Functor.Product.IIdentity as a)
instance Data.Type.Functor.Product.FProd ((,) j)
instance forall k j (w :: j) (a :: k). Data.Type.Functor.Product.PureProd ((,) j) '(w, a)
instance forall k (c :: k -> GHC.Types.Constraint) (a :: k) j (w :: j). c a => Data.Type.Functor.Product.PureProdC ((,) j) c '(w, a)
instance forall k (c :: * -> GHC.Types.Constraint) (g :: k -> *) (a :: k) j (w :: j). c (g a) => Data.Type.Functor.Product.ReifyConstraintProd ((,) j) c g '(w, a)
instance forall j (a :: j) k (b :: k). Data.Singletons.Internal.SingI 'Data.Type.Functor.Product.ISnd
instance forall j k (as :: (j, k)) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Functor.Product.ISnd as a)
instance forall j k (as :: (j, k)) (a :: k). Data.Singletons.Decide.SDecide (Data.Type.Functor.Product.ISnd as a)
instance Data.Type.Functor.Product.FProd GHC.Base.NonEmpty
instance Data.Type.Functor.Product.ProdSing GHC.Base.NonEmpty
instance forall k (as :: [k]) (a :: k). Data.Vinyl.Core.RecApplicative as => Data.Type.Functor.Product.PureProd GHC.Base.NonEmpty (a 'GHC.Base.:| as)
instance forall a1 (c :: a1 -> GHC.Types.Constraint) (a2 :: a1) (as :: [a1]). (c a2, Data.Vinyl.Core.RPureConstrained c as) => Data.Type.Functor.Product.PureProdC GHC.Base.NonEmpty c (a2 'GHC.Base.:| as)
instance forall a1 (c :: * -> GHC.Types.Constraint) (g :: a1 -> *) (a2 :: a1) (as :: [a1]). (c (g a2), Data.Vinyl.Core.ReifyConstraint c g as) => Data.Type.Functor.Product.ReifyConstraintProd GHC.Base.NonEmpty c g (a2 'GHC.Base.:| as)
instance forall k (a :: k) (as :: [k]). Data.Singletons.Internal.SingI 'Data.Type.Functor.Product.NEHead
instance forall k (b :: k) (as :: [k]) (a :: k) (i :: Data.Type.Functor.Product.Index as a). Data.Singletons.Internal.SingI i => Data.Singletons.Internal.SingI ('Data.Type.Functor.Product.NETail i)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Functor.Product.NEIndex as a)
instance forall k (as :: GHC.Base.NonEmpty k) (a :: k). Data.Singletons.Decide.SDecide (Data.Type.Functor.Product.NEIndex as a)
instance forall k j (f :: k -> *) (as :: Data.Either.Either j k). Data.Type.Functor.Product.ReifyConstraintProd (Data.Either.Either j) GHC.Show.Show f as => GHC.Show.Show (Data.Type.Functor.Product.PEither f as)
instance Data.Type.Functor.Product.FProd (Data.Either.Either j)
instance forall k j (e :: j). Data.Type.Functor.Product.PureProd (Data.Either.Either j) ('Data.Either.Left e)
instance forall k j (a :: k). Data.Type.Functor.Product.PureProd (Data.Either.Either j) ('Data.Either.Right a)
instance forall k j (c :: k -> GHC.Types.Constraint) (e :: j). Data.Type.Functor.Product.PureProdC (Data.Either.Either j) c ('Data.Either.Left e)
instance forall b (c :: b -> GHC.Types.Constraint) (a :: b) j. c a => Data.Type.Functor.Product.PureProdC (Data.Either.Either j) c ('Data.Either.Right a)
instance forall k j (c :: * -> GHC.Types.Constraint) (g :: k -> *) (e :: j). Data.Type.Functor.Product.ReifyConstraintProd (Data.Either.Either j) c g ('Data.Either.Left e)
instance forall b (c :: * -> GHC.Types.Constraint) (g :: b -> *) (a :: b) j. c (g a) => Data.Type.Functor.Product.ReifyConstraintProd (Data.Either.Either j) c g ('Data.Either.Right a)
instance forall j k (a :: k). Data.Singletons.Internal.SingI 'Data.Type.Functor.Product.IRight
instance forall j k (as :: Data.Either.Either j k) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Functor.Product.IRight as a)
instance forall j k (as :: Data.Either.Either j k) (a :: k). Data.Singletons.Decide.SDecide (Data.Type.Functor.Product.IRight as a)
instance forall k (f :: k -> *) (as :: GHC.Maybe.Maybe k). Data.Type.Functor.Product.ReifyConstraintProd GHC.Maybe.Maybe GHC.Show.Show f as => GHC.Show.Show (Data.Type.Functor.Product.PMaybe f as)
instance forall k (f :: k -> *) (as :: GHC.Maybe.Maybe k). Data.Type.Functor.Product.ReifyConstraintProd GHC.Maybe.Maybe GHC.Classes.Eq f as => GHC.Classes.Eq (Data.Type.Functor.Product.PMaybe f as)
instance forall k (f :: k -> *) (as :: GHC.Maybe.Maybe k). (Data.Type.Functor.Product.ReifyConstraintProd GHC.Maybe.Maybe GHC.Classes.Eq f as, Data.Type.Functor.Product.ReifyConstraintProd GHC.Maybe.Maybe GHC.Classes.Ord f as) => GHC.Classes.Ord (Data.Type.Functor.Product.PMaybe f as)
instance Data.Type.Functor.Product.FProd GHC.Maybe.Maybe
instance Data.Type.Functor.Product.ProdSing GHC.Maybe.Maybe
instance Data.Type.Functor.Product.PureProd GHC.Maybe.Maybe 'GHC.Maybe.Nothing
instance forall k (a :: k). Data.Type.Functor.Product.PureProd GHC.Maybe.Maybe ('GHC.Maybe.Just a)
instance forall k (c :: k -> GHC.Types.Constraint). Data.Type.Functor.Product.PureProdC GHC.Maybe.Maybe c 'GHC.Maybe.Nothing
instance forall a1 (c :: a1 -> GHC.Types.Constraint) (a2 :: a1). c a2 => Data.Type.Functor.Product.PureProdC GHC.Maybe.Maybe c ('GHC.Maybe.Just a2)
instance forall k (c :: * -> GHC.Types.Constraint) (g :: k -> *). Data.Type.Functor.Product.ReifyConstraintProd GHC.Maybe.Maybe c g 'GHC.Maybe.Nothing
instance forall a1 (c :: * -> GHC.Types.Constraint) (g :: a1 -> *) (a2 :: a1). c (g a2) => Data.Type.Functor.Product.ReifyConstraintProd GHC.Maybe.Maybe c g ('GHC.Maybe.Just a2)
instance forall k (a :: k). Data.Singletons.Internal.SingI 'Data.Type.Functor.Product.IJust
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Functor.Product.IJust as a)
instance forall k (as :: GHC.Maybe.Maybe k) (a :: k). Data.Singletons.Decide.SDecide (Data.Type.Functor.Product.IJust as a)
instance forall k (a :: k) (as :: [k]). Data.Singletons.Internal.SingI 'Data.Type.Functor.Product.IZ
instance forall k (b :: k) (bs :: [k]) (a :: k) (i :: Data.Type.Functor.Product.Index bs a). Data.Singletons.Internal.SingI i => Data.Singletons.Internal.SingI ('Data.Type.Functor.Product.IS i)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Functor.Product.Index as a)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Decide.SDecide (Data.Type.Functor.Product.Index as a)
instance Data.Type.Functor.Product.FProd []
instance Data.Type.Functor.Product.ProdSing []
instance forall k (c :: * -> GHC.Types.Constraint) (f :: k -> *) (as :: [k]). Data.Vinyl.Core.ReifyConstraint c f as => Data.Type.Functor.Product.ReifyConstraintProd [] c f as
instance forall k (c :: k -> GHC.Types.Constraint) (as :: [k]). Data.Vinyl.Core.RPureConstrained c as => Data.Type.Functor.Product.PureProdC [] c as
instance forall k (as :: [k]). Data.Vinyl.Core.RecApplicative as => Data.Type.Functor.Product.PureProd [] as

module Data.Type.Functor.XProduct
type XProd f g = (Prod f (XData g) :: f k -> Type)
fromXProd :: forall f g as. (FProd f, PureProdC f (IsoHKD g) as) => XProd f g as -> Prod f g as
toXProd :: forall f g as. (FProd f, PureProdC f (IsoHKD g) as) => Prod f g as -> XProd f g as
mapProdX :: forall f g h as. FProd f => (forall a. HKD g a -> HKD h a) -> XProd f g as -> XProd f h as
mapProdXEndo :: forall f g as. FProd f => (forall a. HKD g a -> HKD g a) -> XProd f g as -> XProd f g as
imapProdX :: forall f g h as. FProd f => (forall a. Elem f as a -> HKD g a -> HKD h a) -> XProd f g as -> XProd f h as
zipWithProdX :: forall f g h j as. FProd f => (forall a. HKD g a -> HKD h a -> HKD j a) -> XProd f g as -> XProd f h as -> XProd f j as
ixProdX :: FProd f => Elem f as a -> Lens' (XProd f g as) (HKD g a)
traverseProdX :: forall f g h m as. (FProd f, Applicative m) => (forall a. HKD g a -> m (HKD h a)) -> XProd f g as -> m (XProd f h as)
traverseProdXEndo :: forall f g m as. (FProd f, Applicative m) => (forall a. HKD g a -> m (HKD g a)) -> XProd f g as -> m (XProd f g as)
itraverseProdX :: forall f g h m as. (FProd f, Applicative m) => (forall a. Elem f as a -> HKD g a -> m (HKD h a)) -> XProd f g as -> m (XProd f h as)
foldMapProdX :: forall f g m as. (FProd f, Monoid m) => (forall a. HKD g a -> m) -> XProd f g as -> m
ifoldMapProdX :: forall f g m as. (FProd f, Monoid m) => (forall a. Elem f as a -> HKD g a -> m) -> XProd f g as -> m
type XRec (f :: u -> Type) = Rec XData f
pattern (::&) :: forall a (f :: a -> Type) (r :: a) (rs :: [a]). () => () => HKD f r -> XRec f rs -> XRec f (r : rs)
infixr 7 ::&
pattern XRNil :: forall u (f :: u -> Type). () => () => XRec f ([] :: [u])
type XMaybe f = PMaybe (XData f)
pattern XNothing :: XMaybe f  'Nothing
pattern XJust :: HKD f a -> XMaybe f ( 'Just a)
type XEither f = PEither (XData f)
pattern XLeft :: XEither f ( 'Left e)
pattern XRight :: HKD f a -> XEither f ( 'Right a)
type XNERec f = NERec (XData f)
pattern (::&|) :: HKD f a -> XRec f as -> XNERec f (a :| as)
type XTup f = PTup (XData f)
pattern XSnd :: HKD f a -> XTup f '(w, a)
type XIdentity f = PIdentity (XData f)
pattern XIdentity :: HKD f a -> XIdentity f ( 'Identity a)
